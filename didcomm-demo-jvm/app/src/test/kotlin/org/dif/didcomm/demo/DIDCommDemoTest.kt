/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package org.dif.didcomm.demo

import org.dif.didcomm.demo.core.fromJsonToMap
import org.dif.didcomm.demo.core.getDidDocAuthentications
import org.dif.didcomm.demo.core.getDidDocKeyAgreements
import org.dif.didcomm.demo.core.getDidDocServices
import org.dif.didcomm.demo.secrets.SecretResolverDemo
import org.dif.peerdid.core.DIDDocVerMaterialFormat
import org.dif.peerdid.isPeerDID
import org.dif.peerdid.resolvePeerDID
import org.dif.utils.isDID
import org.junit.Before
import org.junit.Rule
import org.junit.jupiter.params.provider.MethodSource
import org.junit.rules.TemporaryFolder
import kotlin.test.*


class DIDCommDemoTest {


    @Rule
    @JvmField
    val secretsFolder = TemporaryFolder()

    lateinit var demo: DIDCommDemo


    @Before
    fun setup() {
        val secretsFile = secretsFolder.newFile("secrets.json")
        demo = DIDCommDemo(SecretResolverDemo(secretsFile.absolutePath))
    }

    private fun checkExpectedDIDDoc(
        peerDID: String,
        authKeysCount: Int, agreemKeysCount: Int
    ) {
        val didDocJson = resolvePeerDID(peerDID)
        val didDoc = fromJsonToMap(didDocJson)
        val authentications = getDidDocAuthentications(didDoc)
        val keyAgreements = getDidDocKeyAgreements(didDoc)
        val services = getDidDocServices(didDoc)
        assertEquals(authKeysCount, authentications.size)
        assertEquals(agreemKeysCount, keyAgreements.size)

    }

    @Test
    fun testCreatePeerDidDefault() {
        val peerDID = demo.createPeerDID()
        assertTrue(isPeerDID(peerDID))
        assertTrue(peerDID.startsWith("did:peer:2"))
        assertEquals(
            2, demo.secretsResolver.getKids().size
        )
        demo.secretsResolver.getKids().forEach {
            assertTrue(it.startsWith(peerDID))
        }
        checkExpectedDIDDoc(peerDID, 1, 1)
    }

    @Test
    fun testCreatePeerDidNumalgo0() {
        val peerDID = demo.createPeerDID(authKeysCount = 1, agreementKeysCount = 0)
        assertTrue(isPeerDID(peerDID))
        assertTrue(peerDID.startsWith("did:peer:0"))
        assertEquals(
            1, demo.secretsResolver.getKids().size
        )
        demo.secretsResolver.getKids().forEach {
            assertTrue(it.startsWith(peerDID))
        }
        checkExpectedDIDDoc(peerDID, 1, 0)
    }

    @Test
    fun testResolvePeerDID() {
        val did = "did:peer:0z6MkqRYqQiSgvZQdnBytw86Qbs2ZWUkGv22od935YF4s8M7V"
        val didDocJson = DIDCommDemo.resolvePeerDID(did, format = DIDDocVerMaterialFormat.JWK)
        val didDoc = fromJsonToMap(didDocJson)
        assertTrue("authentication" in didDoc)
        assertEquals(did, didDoc["id"])
    }


    private fun fromDID() =
        demo.createPeerDID(authKeysCount = 2, agreementKeysCount = 2)

    private fun toDID() =
        demo.createPeerDID(authKeysCount = 2, agreementKeysCount = 2)


    @Test
    @MethodSource("messages")
    fun testPackUnpackAuthcrypt() {
        val message = "{'aaa': 'bbb'}"
        val from = fromDID()
        val to = toDID()
        val packed = demo.pack(message, from = from, to = to)

        val unpackRes = demo.unpack(packed.packedMessage)
        assertEquals(message, unpackRes.message)
        assertEquals(from, unpackRes.from)
        assertEquals(to, unpackRes.to)

        assertTrue(unpackRes.res.metadata.encrypted)
        assertTrue(unpackRes.res.metadata.authenticated)
        assertTrue(unpackRes.res.metadata.anonymousSender)
        assertFalse(unpackRes.res.metadata.nonRepudiation)
    }

    @Test
    @MethodSource("messages")
    fun testPackUnpackAnoncrypt() {
        val message = "{'aaa': 'bbb'}"
        val to = toDID()
        val packed = demo.pack(message, to = to)

        val unpackRes = demo.unpack(packed.packedMessage)
        assertEquals(message, unpackRes.message)
        assertNull(unpackRes.from)
        assertEquals(to, unpackRes.to)

        assertTrue(unpackRes.res.metadata.encrypted)
        assertFalse(unpackRes.res.metadata.authenticated)
        assertTrue(unpackRes.res.metadata.anonymousSender)
        assertFalse(unpackRes.res.metadata.nonRepudiation)
    }

    @Test
    @MethodSource("messages")
    fun testPackUnpackAuthcryptSigned() {
        val message = "hello"
        val from = fromDID()
        val to = toDID()
        val packed = demo.pack(message, from = from, to = to, signFrom = from)

        val unpackRes = demo.unpack(packed.packedMessage)
        assertEquals(message, unpackRes.message)
        assertEquals(from, unpackRes.from)
        assertEquals(to, unpackRes.to)

        assertTrue(unpackRes.res.metadata.encrypted)
        assertTrue(unpackRes.res.metadata.authenticated)
        assertTrue(unpackRes.res.metadata.anonymousSender)
        assertTrue(unpackRes.res.metadata.nonRepudiation)
    }

    @Test
    fun testPackUnpackAuthcryptSenderNotProtected() {
        val message = "{'aaa': 'bbb'}"
        val from = fromDID()
        val to = toDID()
        val packed = demo.pack(message, from = from, to = to, protectSender = false)

        val unpackRes = demo.unpack(packed.packedMessage)
        assertEquals(message, unpackRes.message)
        assertEquals(from, unpackRes.from)
        assertEquals(to, unpackRes.to)

        assertTrue(unpackRes.res.metadata.encrypted)
        assertTrue(unpackRes.res.metadata.authenticated)
        assertFalse(unpackRes.res.metadata.anonymousSender)
        assertFalse(unpackRes.res.metadata.nonRepudiation)
    }
}
